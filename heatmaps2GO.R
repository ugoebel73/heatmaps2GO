library(org.Mm.eg.db)
##library(tidyverse)
library(dplyr)

source("functions.R")
source("functions_IDversions.R")

org_name <- "Mus musculus"
ensembl_version <- 102
## --------------------------------------------------------------------------
## biomaRt as a source for Ensembl gene and GO data 
## (alternative to the NCBI based OrgDb package org.Mm.eg.db):
mart102 <- biomaRt::useMart(biomart="ENSEMBL_MART_ENSEMBL",
                            dataset="mmusculus_gene_ensembl",
                            host=biomaRt::listEnsemblArchives() %>% 
                              
                              filter(version=="102") %>% 
                              pull(url))

## --------------------------------------------------------------------------

## currently valid GO terms from GO.db:
GO_terms <- DBI::dbGetQuery(GO.db::GO_dbconn(), 
                            "SELECT go_id as GO_term, 
                             ontology as Ontology FROM go_term") 

GO_synonyms <- as.list(GO.db::GOSYNONYM)
names(GO_synonyms) <- sapply(GO_synonyms,function(x)x@GOID)

## can get definitions from
## as.list(GO.db::GOTERM)  <<<--- explore! 
GO_info <- as.list(GO.db::GOTERM)
names(GO_info) <- sapply(GO_info,function(x)x@GOID)

print(GO.db::GO.db) ## later also used to get parent/child relations
##GODb object:
#  | GOSOURCENAME: Gene Ontology
#| GOSOURCEURL: http://current.geneontology.org/ontology/go-basic.obo
#| GOSOURCEDATE: 2021-09-01
#| Db type: GODb
#| package: AnnotationDbi
#| DBSCHEMA: GO_DB
#| GOEGSOURCEDATE: 2021-Sep13
#| GOEGSOURCENAME: Entrez Gene
#| GOEGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA
#| DBSCHEMAVERSION: 2.1

## --------------------------------------------------------------------------
## GO evidence code definitions:
path <- "DATA/GO_evidence_codes.tsv"
GO_evidence <- read.csv(path,sep="\t",comment.char="#")

## --------------------------------------------------------------------------
## For comparison: the Enrichr GO databases I have used in previous analyses:
source("functions_enrichr.R")
Enrichr_dbs <- sapply(read_Enrichr_dbs(Enrichr_base="DATA"),
                      function(x) {
                        y <- x$genes
                        names(y) <- extractCapturedSubstrings(
                          pattern="\\((GO:\\d+)\\)$",
                          string=names(y))    
                        y 
                      })
## --------------------------------------------------------------------------

## GO terms for which we want to draw heatmaps:
our_GO_terms <- read.csv("GO_terms.csv",comment.char="#")[,"GO_term"]

## --------------------------------------------------------------------------
## the DGE result on which the heatmaps will be based:
path <- "DATA/DGE_plusVOOM_limma_CONTRASTS_FROM_MEANS_MODEL_all_Dec21_2021.xlsx"
DGE_results <- sapply(readxl::excel_sheets(path),
                      function(n) readxl::read_xlsx(path,sheet=n),
                      simplify=FALSE)

## --------------------------------------------------------------------------
## the v100/102 Ensembl IDs actually used in the DGE analysis:
DGE_genes <- DGE_results[[1]]$ensembl_geneid ## same for all comparisons 
                                             ## -> use [[1]]


## --------------------------------------------------------------------------
## map DGE_genes to Ensembl v103, which was current on 2021-Apr13, 
## the ENSOURCEDATE of org.Mm.eg.db 3.14.0
ensembl_IDmapper_results_Jan31_2022 <- 
  "./DATA/KLjMWDn3CtXEFwcB-7995102.idmapper.txt" ## for input=DGE_genes,
                                                 ## run by hand
mappedIDs_v103 <- 
  map_Ensembl_versions_from_IDMapper_output(ensembl_IDmapper_results_Jan31_2022,
                                            target_release="103",
                                            query_IDs=DGE_genes)

## How many IDs are affected?
sum(mappedIDs_v103$retired | mappedIDs_v103$missing)
## [1] 106
sum(mappedIDs_v103$changed)
## [1] 19
sum(mappedIDs_v103$retired | mappedIDs_v103$missing | mappedIDs_v103$changed) /
length(DGE_genes)
## [1] 0.00688971

## convert to a vector for mapping old IDs to current IDs:
DGE_genes_v103 <- setNames(DGE_genes,DGE_genes)
i <- which(mappedIDs_v103$changed)
DGE_genes_v103[rownames(mappedIDs_v103)[i]] <- mappedIDs_v103[i,"newID"]
i <- which(mappedIDs_v103$retired | mappedIDs_v103$missing)
DGE_genes_v103[rownames(mappedIDs_v103)[i]] <- NA

## ..........................................................................
## how do the IDmapper results relate to the annotation files?
v103_gtf_file <- "./DATA/Mus_musculus.GRCm39.103.gtf"
v103_gtf <- rtracklayer::readGFF(v103_gtf_file,version=2)
v100_gtf_file <- "./DATA/Mus_musculus.GRCm38.100.gtf"
v100_gtf <- rtracklayer::readGFF(v100_gtf_file,version=2)

v103_fna_file <- "./DATA/Mus_musculus.GRCm39.103.rna.fa"
v103_fna <- Biostrings::readDNAStringSet(v103_fna_file)
v100_fna_file <- "./DATA/Mus_musculus.GRCm38.100.rna.fa"
v100_fna <- Biostrings::readDNAStringSet(v100_fna_file)

## ..........................................................................
table(DGE_genes %in% v103_gtf$gene_id)
##FALSE  TRUE 
##  302 17841 

g <- names(DGE_genes_v103)[which(is.na(DGE_genes_v103) |
                                   !(names(DGE_genes_v103)==DGE_genes_v103))]
all(g %in% setdiff(DGE_genes,v103_gtf$gene_id))
##[1] TRUE ## all retired|missing|changed v100 IDs are indeed not in v103_gtf

## v100_gtf itself is missing IDs:
table(DGE_genes %in% v100_gtf$gene_id)
## FALSE  TRUE 
##   218 17925 
all(DGE_genes[!(DGE_genes %in% v100_gtf$gene_id)] %in% 
    DGE_genes[!(DGE_genes %in% v103_gtf$gene_id)])
##[1] TRUE  ## a subset of the IDs missing in v103

## The kallisto index was based on Mus_musculus.GRCm38.100.rna.fa.
## Indeed, this file does contain all IDs -- but the v100 gtf file does not!
genes_from_rna_fasta_v100 <- 
  extractCapturedSubstrings("\\sgene:(ENSMUSG[^.]+)\\.\\d+",names(v100_fna))
table(DGE_genes %in% genes_from_rna_fasta_v100)
## TRUE 
##18143 

## In Ensembl version v103, these IDs are missing from the fasta file
## as well as from the gtf file.
genes_from_rna_fasta_v103 <- 
  extractCapturedSubstrings("\\sgene:(ENSMUSG[^.]+)\\.\\d+",names(v103_fna))
table(DGE_genes %in% genes_from_rna_fasta_v103)
## FALSE  TRUE 
##  302 17812 

## Make sure that the 302 genes are indeed the same in both cases:
identical(x <- sort(setdiff(DGE_genes,v103_gtf$gene_id)),
               sort(setdiff(DGE_genes,genes_from_rna_fasta_v103)))
## [1] TRUE

unexplained <- setdiff(x,g) ## not explained by retired|missing|changed

tmp <- unique(t(sapply(names(v100_fna)[genes_from_rna_fasta_v100 %in% unexplained],
                       extractCapturedSubstrings,
                       pattern="\\s([^:\\s]+):GRCm38:([^:]+).+\\sgene:(ENSMUSG[^.]+)\\.\\d+")))
table(tmp[,1]) ## it's not only stuff on scaffolds
## chromosome   scaffold 
##        172          5 
table(grepl("^\\d+$",tmp[,2]))
## FALSE  TRUE 
##   157    20 [TRUE  = pure numerical=regular nuclear chromosome
##              FALSE = other = mostly PATCHes] [M or X/Y not among them]

unname(tmp[,3][grepl("^\\d+$",tmp[,2])]) ## unexplained on regular chromosomes


## Possible way to deal with the version discrepancy (if we don't decide to
## just ignore it):
## Of the 302 IDs missing in the v103 .rna.fa file but present in v100,
## 125 are explained by explicit retirements or ID changes (source: IDMapper),
## and 157 are on non-canonical chromosomes or scaffolds.
## It could be justified to simply discard genes with any of these 282 IDs. 
## The 20 remaining "unexplained" IDs I would leave in, given that they are 
## still listed in the IDMapper result.
##
## On the other hand it could also be justified to leave everything in,
## because indeed all DGE_genes have an ENSEMBL entry in org.Mm.eg.db
## (see below).
## This means that the GOALL<->ENSEMBL relation in this OrgDb package
## (with GOSOURCEDATE: 2021-09-01
##       ENSOURCEDATE: 2021-Apr13 ) does know about the problematic IDs 
## and should have assigned them meaningful GO terms (?).


## --------------------------------------------------------------------------
## significantly regulated  v100/102 Ensembl IDs:
minAbsLFC <- log2(1.5) ## that is, abs(FoldChange)>=1.5 ##
maxq_DGE <- 0.05
significant_DGE_genes <- Reduce(union,
                                lapply(DGE_results,
                                       function(x) {
                                          x %>% 
                                          filter((adj.P.Val <= maxq_DGE) &
                                                 (logFC     >= minAbsLFC)) %>%
                                          pull(ensembl_geneid)
                                        })
                         )
                                
## --------------------------------------------------------------------------

## get an Ensembl ID (from Ens102 through biomaRt) <-> Gene Ontology relation 
## from the Mouse OrgDb package
## (note that the OrgDb genome builds are from NCBI, not Ensembl,
## and that moreover ENSOURCEDATE: 2021-Apr13 suggests that the Ensembl data
## in the object are > v102 and likely from GRCm39, not GRCm38 as v102!)
org_genes2GO <- AnnotationDbi::select(org.Mm.eg.db,
                                      keys=biomaRt::getBM(
                                        attributes = "ensembl_gene_id",  
                                        mart=mart102)[,1],
                                      columns=c("SYMBOL",
                                                "GOALL",
                                                "EVIDENCEALL",
                                                "ONTOLOGYALL"),
                                      keytype="ENSEMBL")                   %>%
  
                     filter(!is.na(GOALL) & (GOALL %in% GO_terms$GO_term)) %>%
                     rename(Evidence=EVIDENCEALL)                          %>%
                     rename(GO_term=GOALL)                                 %>%
                     rename(Ontology=ONTOLOGYALL)             
## NOTE: before filtering, all DGE_genes are represented in the ENSEMBL column)
##       (not shown)

## add an indicator column for whether or not a gene is in DGE_genes:
org_genes2GO$in_DGE <- org_genes2GO$ENSEMBL %in% DGE_genes
org_genes2GO$in_sig <- org_genes2GO$ENSEMBL %in% significant_DGE_genes

## note that quite a fraction of the DGE_genes are not found:
length(unique(org_genes2GO %>% filter(in_DGE) %>% pull(ENSEMBL)))
##[1] 15296

## but all of them are in the package, although 125 of them should not
## exist any more in Ensembl v103:
length(intersect(bla$ENSEMBL, DGE_genes))
## [1] 18143

## --------------------------------------------------------------------------
## get an Ensembl ID <-> Gene Ontology relation from biomRt:
biomaRt_v102_genes2GO <-    biomaRt::getBM(attributes = c("ensembl_gene_id",
                                                          "external_gene_name",
                                                          "go_id",
                                                          "go_linkage_type"),
                                        mart=mart102)                 %>%
                            
                                filter(go_id %in% GO_terms$GO_term)   %>% 
                                rename(ENSEMBL=ensembl_gene_id)       %>%
                                rename(SYMBOL=external_gene_name)     %>%
                                rename(Evidence=go_linkage_type)      %>%
                                rename(GO_term=go_id)                 %>%
                            left_join(GO_terms,by="GO_term") ## join ontology

biomaRt_v102_genes2GO$in_DGE <- biomaRt_v102_genes2GO$ENSEMBL %in% DGE_genes
biomaRt_v102_genes2GO$in_sig <- 
  biomaRt_v102_genes2GO$ENSEMBL %in% significant_DGE_genes

## Why biomaRt?
## pro: - version can be selected (while org.Mm.eg.de is current version only)
##      - contains GO data (missing in the equivalent EnsDb package
##        from AnnotationHub, which would be native Ensembl like biommaRt) 
## con: - GO data seem to be a GO slim (at least the Ensembl REST API 
##        returns goslim data when queried for GO)
##      - not entirely clear how the gene <-> GO term relation is defined:
##        In compliance with the Ensembl model 
##        (see https://support.bioconductor.org/p/122315/) the terms seem to
##        directly associated with genes (<- transcripts), the relation not
##        being propagated to children of a term. I infer this from the fact
##        that when the genes associated with the children are manually 
##        added, then the number of genes annotated to  "our_GO_terms"
##        becomes similar to the number from org.Mm.eg.db, 
##        while otherwise it is much smaller for most terms.
## --------------------------------------------------------------------------
## "genes per GO term" lists for our_GO_terms by org.Mm.eq.db and by biomaRt:

GO2genes <- sapply(c("org", "biomaRt_v102"),
                  function(var) {
                    var <- paste0(var, "_genes2GO")
                    lapply(list(all=TRUE,
                                dge=eval(as.symbol(var))$in_DGE,
                                sig=eval(as.symbol(var))$in_sig),
                            function(cnd) {
                                eval(as.symbol(var))[cnd,]              %>% 
                                     filter(GO_term %in% our_GO_terms)  %>% 
                                     select(-in_DGE)                    %>% 
                                     nest_by(GO_term,
                                             Ontology,.key="gene_set")
                       })
            },simplify = FALSE) ## sapply sets the names -> simpler

## note that nest_by sorts by GO term, 
## so the order is different from "our_GO_terms"!

## --------------------------------------------------------------------------
## accessor function to extract a column of the nested tibbles 
## in GO2genes[[]]:

get_geneset_column <- function(tag="all",
                               obj="GO2genes$org",
                               field="ENSEMBL") {
  l <- eval(parse(text=paste0('purrr::map(',obj,'[["',
                              tag,
                              '"]]$gene_set,function(x) x %>% dplyr::pull(',
                              field,
                              '))')))
  names(l) <- eval(parse(text=paste0(obj,'[["',tag,'"]]$GO_term')))
  l <- l[our_GO_terms] ## orders and sets lists of missing terms to NULL
  names(l) <- our_GO_terms ## in case there have been missing lists
  
  l
}  
## --------------------------------------------------------------------------
## Explore how gene sets defined by or.Mm.eg.de and biomaRt relate:

GO_genesets <- tibble(GO_term=our_GO_terms,
                    org_all=lapply(get_geneset_column(), unique),
                    org_dge=lapply(get_geneset_column(tag="dge"), unique),
                    org_sig=lapply(get_geneset_column(tag="sig"), unique),
                    
                    biomaRt_all=lapply(get_geneset_column(
                      obj = "GO2genes$biomaRt_v102"), unique),
                    biomaRt_dge=lapply(get_geneset_column(
                      tag="dge",
                      obj = "GO2genes$biomaRt_v102"),unique),
                    biomaRt_sig=lapply(get_geneset_column(
                      tag="sig",
                      obj = "GO2genes$biomaRt_v102"),unique)
                    )
##...........................................................................
## augment Ensembl v102 <-> GO associations  by the Ensembl v102 genes 
## associated with the children of each of "our_GO_terms" (as defined by GO.db):

child_terms <-  sapply(our_GO_terms,
                       function(x) {
                         cat(x,"\n")
                         more_specific_GOs(x,GO2entrez=org.Mm.egGO2EG)
                       },simplify=FALSE)

for(tag in c("all","dge","sig")) {
  GO_genesets[[paste0("biomaRt_",tag,"_inclusive")]] <-
        lapply(our_GO_terms,
               function(x) {
                 ##browser()
                 cnd <- biomaRt_v102_genes2GO$GO_term %in% child_terms[[x]]
                 if(tag=="dge") {
                   cnd <- cnd &  biomaRt_v102_genes2GO$in_DGE
                 } else if (tag=="sig") {
                   cnd <- cnd &  biomaRt_v102_genes2GO$in_sig
                 } 
                 unique(biomaRt_v102_genes2GO$ENSEMBL[cnd])
               })
}

## ..........................................................................
## Where are the proteasome-related genes that are in the Enrichr heatmaps,
## but no longer in the org.Mm.eg.db-based ones?
load("DATA/groups_464.RData")
proteasome_symbols <- groups_464[[3]]

biomaRt_v102_genes2GO %>% 
  filter((SYMBOL %in% proteasome_symbols) &
         (ENSEMBL %in% Reduce(union,
                              GO_genesets$biomaRt_all_inclusive))) %>%
  select(ENSEMBL,SYMBOL) %>% distinct(ENSEMBL,SYMBOL)
## a single gene (same for "all" and "dge")
##              ENSEMBL SYMBOL
## 1 ENSMUSG00000005779  Psmb4


org_genes2GO %>% 
  filter((SYMBOL %in% proteasome_symbols) &
           (ENSEMBL %in% Reduce(union,
                                GO_genesets$org_all))) %>%
  select(ENSEMBL,SYMBOL) %>% distinct(ENSEMBL,SYMBOL)
## the same single gene

## ..........................................................................
## Where is the Enrichr annotation coming from?

load("/home/ugoebel/CECAD/Pipeline/Git/Heatmaps/heatmaps2GO_test/Reproduce/enrichr_proteasome_mapping.RData")
## (this is the group 3 of groups_464, consisting of proteasome genes only)

enrichr_proteasome_mapping <- unlist(enrichr_proteasome_mapping) ## all length 1
length(enrichr_proteasome_mapping)
##[1] 25 

all(enrichr_proteasome_mapping %in% DGE_genes)
##[1] TRUE
load("/home/ugoebel/CECAD/Pipeline/Git/Heatmaps/heatmaps2GO_test/Reproduce/enrichr_proteasome_GOs.RData")
enrichr_proteasome_GOs <- sub("\\.",":",sub("\\s+","", enrichr_proteasome_GOs))
##1] "GO:0070498:100%" "GO:0038061:100%" "GO:0033209:100%" "GO:0019221:100%"
##[5] "GO:0071456:100%" "GO:0002479:96%"  "GO:0043312:28%"  "GO:0071357:4%"  
##[9] "GO:0050727:4%"  

all(sub(":\\d+%","",enrichr_proteasome_GOs) %in% GO_terms$GO_term)
##[1] TRUE  ## should be TRUE, because this is a subset of our_GO_terms

g <- biomaRt_v102_genes2GO %>% filter(ENSEMBL %in% 
                                      enrichr_proteasome_mapping)  %>%
                                      distinct(ENSEMBL) %>% pull(ENSEMBL)
length(g)
##[1] 25 ## all 25 genes are actually represented

table(g %in% DGE_genes) ## and they are all in our analysis set
##TRUE 
##  25 

g_symbols <- biomaRt_v102_genes2GO %>% filter(ENSEMBL %in% g) %>%
                                       distinct(SYMBOL) %>% pull(SYMBOL)
##[1] "Psmc4"  "Psme1"  "Psme2"  "Psmb3"  "Psmb4"  "Psmb5"  "Psmd12" "Psma7" 
##[9] "Psmd4"  "Psma5"  "Psmb2"  "Psmb6"  "Psmb7"  "Psma3"  "Psmb9"  "Psmf1" 
##[17] "Psmb8"  "Psma6"  "Uba52"  "Psmd3"  "Psmc1"  "Psmc2"  "Psma2"  "Psmb10"
##[25] "Psmb1" 

## But they are not associated with our_GO_terms (or their children) 
## in biomaRt or in org.Mm.eg.db, except for one gene:
tmp <- setNames(sapply(GO_genesets[["biomaRt_all_inclusive"]],
                       function(x)intersect(x,g)),
                GO_genesets$GO_term)
tmp[sapply(tmp,length)>0]
##$`GO:0050727` 
##[1] "ENSMUSG00000005779"

tmp <- setNames(sapply(GO_genesets[["org_all"]],
                       function(x)intersect(x,g)),
                GO_genesets$GO_term)
tmp[sapply(tmp,length)>0]
##$`GO:0050727`
##[1] "ENSMUSG00000005779"

GO_info[["GO:0050727"]]@Term
##[1] "regulation of inflammatory response"


## NOTE that although GO:0050727 is represented in the "proteasome gene set"
##      of the Enrichr-based heatmap, it is a minor component
##      (only 4%, which is 1/25=0.04 = 1 out of the 25 genes
##       -- likely ENSMUSG00000005779).

## With which GO terms were the 25 genes associated in the Enrichr GO database?
sapply(toupper(g_symbols),function(this_g)  
  names(which(
    sapply(Enrichr_dbs[["GO_Biological_Process_2018"]][our_GO_terms],
           function(x)this_g %in% x)
    ))
)
## $PSMC4
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSME1
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSME2
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB3
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB4
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB5
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMD12
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMA7
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMD4
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMA5
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMB2
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB6
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB7
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMA3
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB9
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMF1
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB8
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0071357" "GO:0002479" "GO:0071456"
## $PSMA6
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0050727" "GO:0002479" "GO:0071456"
## $UBA52
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0071456"
## $PSMD3
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMC1
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMC2
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMA2
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"
## $PSMB10
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0071456"
## $PSMB1
## [1] "GO:0070498" "GO:0038061" "GO:0033209" "GO:0019221" "GO:0002479" "GO:0043312" "GO:0071456"                        

## With which GO terms are the 25 genes associated in the biomaRt database?
t <- biomaRt_v102_genes2GO %>% filter(ENSEMBL %in% g) %>%
                               distinct(GO_term) %>% pull(GO_term)
length(unique(t))
##[1] 97
length(intersect(our_GO_terms,t))
##[1] 0
## the 25 genes *are* associated with 97 different GO terms, 
## but non is even a synonym of our_GO_terms:

length(which(t %in% names(GO_synonyms)))
##[1] 22
sapply(GO_synonyms[intersect(t, names(GO_synonyms))],
       function(x) any(our_GO_terms %in% x@Synonym))
#GO:0016887 GO:0030163 GO:0005515 GO:0008233 GO:0005839 GO:0004175 GO:0036064 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0003674 GO:0006511 GO:0019882 GO:0003723 GO:0007519 GO:0003735 GO:0006412 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0005840 GO:0022625 GO:0022627 GO:0030234 GO:0050790 GO:0016020 GO:0000902 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0042098 
#FALSE 
sapply(GO_synonyms[intersect(t, names(GO_synonyms))],
       function(x) any(our_GO_terms %in% x@Secondary))
#GO:0016887 GO:0030163 GO:0005515 GO:0008233 GO:0005839 GO:0004175 GO:0036064 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0003674 GO:0006511 GO:0019882 GO:0003723 GO:0007519 GO:0003735 GO:0006412 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0005840 GO:0022625 GO:0022627 GO:0030234 GO:0050790 GO:0016020 GO:0000902 
#FALSE      FALSE      FALSE      FALSE      FALSE      FALSE      FALSE 
#GO:0042098 
#FALSE 

## these are the biological themes 
## with which the 25 genes are associated in GO.db
## (BP ontology, because our_GO_terms are all BP):
tmp <- sapply(t,
              function(x) {
                if (GO_info[[x]]@Ontology=="BP") GO_info[[x]]@Term
                else                             NULL
             })
tmp <- tmp[sapply(tmp,length)>0]
## $`GO:0030163`
## [1] "protein catabolic process"
## $`GO:1901800`
## [1] "positive regulation of proteasomal protein catabolic process"
## $`GO:0001824`
## [1] "blastocyst development"
## $`GO:0045899`
## [1] "positive regulation of RNA polymerase II transcription preinitiation complex assembly"
## $`GO:0019884`
## [1] "antigen processing and presentation of exogenous antigen"
## $`GO:0010950`
## [1] "positive regulation of endopeptidase activity"
## $`GO:0061136`
## [1] "regulation of proteasomal protein catabolic process"
## $`GO:2000045`
## [1] "regulation of G1/S transition of mitotic cell cycle"
## $`GO:0043161`
## [1] "proteasome-mediated ubiquitin-dependent protein catabolic process"
## $`GO:0006508`
## [1] "proteolysis"
## $`GO:0051603`
## [1] "proteolysis involved in cellular protein catabolic process"
## $`GO:0010498`
## [1] "proteasomal protein catabolic process"
## $`GO:0010499`
## [1] "proteasomal ubiquitin-independent protein catabolic process"
## $`GO:0002862`
## [1] "negative regulation of inflammatory response to antigenic stimulus"
## $`GO:0006979`
## [1] "response to oxidative stress"
## $`GO:0006511`
## [1] "ubiquitin-dependent protein catabolic process"
## $`GO:0043248`
## [1] "proteasome assembly"
## $`GO:0010243`
## [1] "response to organonitrogen compound"
## $`GO:0014070`
## [1] "response to organic cyclic compound"
## $`GO:0052548`
## [1] "regulation of endopeptidase activity"
## $`GO:0002376`
## [1] "immune system process"
## $`GO:2000116`
## [1] "regulation of cysteine-type endopeptidase activity"
## $`GO:1901799`
## [1] "negative regulation of proteasomal protein catabolic process"
## $`GO:0030154`
## [1] "cell differentiation"
## $`GO:0045444`
## [1] "fat cell differentiation"
## $`GO:0019882`
## [1] "antigen processing and presentation"
## $`GO:0051092`
## [1] "positive regulation of NF-kappaB transcription factor activity"
## $`GO:0007519`
## [1] "skeletal muscle tissue development"
## $`GO:0006412`
## [1] "translation"
## $`GO:0016567`
## [1] "protein ubiquitination"
## $`GO:0019941`
## [1] "modification-dependent protein catabolic process"
## $`GO:0042176`
## [1] "regulation of protein catabolic process"
## $`GO:0050790`
## [1] "regulation of catalytic activity"
## $`GO:1901215`
## [1] "negative regulation of neuron death"
## $`GO:0000902`
## [1] "cell morphogenesis"
## $`GO:0042098`
## [1] "T cell proliferation"

sapply(our_GO_terms,function(x)length(intersect(child_terms[[x]],names(tmp))))
##GO:0070498 GO:0038061 GO:0033209 GO:0019221 GO:0071357 GO:0050727 GO:0002479 
##         0          0          0          0          0          1          0 
##GO:0043312 GO:0071456 GO:0036294 
##         0          0          0 
## None except one of the terms is a child of our_GO_terms in GO.db,
## where the sole matching term is in our_GO_terms itself and 
## contains the sole matching gene (see above).

## Likely the information transfer was via
## ENSEMBL from DGE (1)-> symbol (2)-> mapped to (?human) Enrichr symbol 
##                  (3)-> associated with GO term in Enrichr database
##                  (4)-> back-associated with original Ensembl ID
##                        (implicitly by matrix row of origin)
## after (1)->, the information on the original Ensembl ID is lost;
## GO terms from other genes which happen to map to an (Enrichr flavor!) symbol 
## will be transferred back to the Ensembl ID.


## see also GO.db.pdf under GOTERM:
##All the obsolete GO terms are under the nodes 
## "obsolete molecular function" (GO:0008369), 
## "obsolete cellular component" (GO:0008370), and 
## "obsolete biological process" (GO:0008371) .. " .. NOT in my version?
## But:
obsolete <- names(as.list(GO.db::GOOBSOLETE))
length(obsolete)
##[1] 3499
table(names(Enrichr_dbs$GO_Biological_Process_2018) %in% obsolete)
##FALSE  TRUE 
## 5045    58 
## *not* a sizeable number 
## --------------------------------------------------------------------------
## What about biomaRt?
table(unique(biomaRt_v102_genes2GO %>% 
               filter(Ontology=="BP") %>% 
               pull(GO_term))  %in% obsolete)
## FALSE 
## 12447
## note that these are more terms than in Enrichr

## --------------------------------------------------------------------------
## --------------------------------------------------------------------------
## --------------------------------------------------------------------------
## prepare input for heatmaps:
indicators <- sapply(colnames(GO_genesets)[-1],
                     function(n) make_setMembership_vectors(
                                            setNames(GO_genesets[[n]],
                                                     GO_genesets[["GO_term"]])
                                            ),
                    simplify=FALSE)

geneset <- "biomaRt_sig_inclusive"
m <- as.matrix(indicators[[geneset]][1:(ncol(indicators[[geneset]])-2)])
nclus <- 8
clusters <-  cluster_setMembership_vectors(by="hamming", 
                                           v=m,nclus=nclus)
  
hamming_clusters <- sapply(clusters,
                           function(i) indicators[[geneset]][i,], 
                           simplify=FALSE)
## OK after removing the error in the definition of GO_genes
## (terms were wrongly sorted for the appended _sig columns)


clusters6 <-  cluster_setMembership_vectors(by="hamming", 
                                            v=m,nclus=6)

hamming_clusters6 <- sapply(clusters6,
                            function(i) indicators[[geneset]][i,], 
                            simplify=FALSE)
## worse

clusters7 <-  cluster_setMembership_vectors(by="hamming", 
                                            v=m,nclus=7)

hamming_clusters7 <- sapply(clusters7,
                            function(i) indicators[[geneset]][i,], 
                            simplify=FALSE)


clusters5 <-  cluster_setMembership_vectors(by="hamming", 
                                            v=m,nclus=5)

hamming_clusters5 <- sapply(clusters5,
                            function(i) indicators[[geneset]][i,], 
                            simplify=FALSE)

km_solutions <- cluster_setMembership_by_kmeans(m,  nruns=10000,
                                                iter_max=5000, 
                                                nstart=10,
                                                nclus=8,verbose=TRUE) # ~4min
length(km_solutions)
##[1] 6284

scores <- sapply(km_solutions, 
                 function(x) mean(sapply(x,
                                         function(i) 
                                            hammingLike_matrix_score(
                                            m[i,,drop=FALSE],zero_penalty=0.01)
                                         )
                                  )
                 )
minsz <- sapply(km_solutions,function(x) min(sapply(x,length)))

km_clusters <- sapply(km_solutions[[which.max(scores)]],
                      function(i) indicators[[geneset]][i,], simplify=FALSE)
km_clusters2 <- sapply(km_solutions[minsz>1][[which.max(scores[minsz>1])]],
                      function(i) indicators[[geneset]][i,], simplify=FALSE)




m_org_sig <- as.matrix(indicators[["org_sig"]]
                       [1:(ncol(indicators[["org_sig"]])-2)])
nclus <- 8
clusters_org_sig <-  cluster_setMembership_vectors(by="hamming", 
                                           v=m_org_sig,nclus=nclus)

hamming_clusters_org_sig <- sapply(clusters_org_sig,
                                   function(i) indicators[["org_sig"]][i,], 
                                   simplify=FALSE)
nclus <- 7
clusters7_org_sig <-  cluster_setMembership_vectors(by="hamming", 
                                                   v=m_org_sig,nclus=nclus)

hamming_clusters7_org_sig <- sapply(clusters7_org_sig,
                                   function(i) indicators[["org_sig"]][i,], 
                                   simplify=FALSE)

nclus <- 6
clusters6_org_sig <-  cluster_setMembership_vectors(by="hamming", 
                                                    v=m_org_sig,nclus=nclus)

hamming_clusters6_org_sig <- sapply(clusters6_org_sig,
                                    function(i) indicators[["org_sig"]][i,], 
                                    simplify=FALSE)

km_solutions_org_sig <- cluster_setMembership_by_kmeans(m_org_sig,  nruns=10000,
                                                iter_max=5000, 
                                                nstart=10,
                                                nclus=8,verbose=TRUE) # ~4min
length(km_solutions_org_sig)
##[1] 4841

scores_org_sig <- sapply(km_solutions_org_sig, 
    function(x) mean(sapply(x,
                            function(i) 
                              hammingLike_matrix_score(
                                    m_org_sig[i,,drop=FALSE],zero_penalty=0.01)
                           )))

minsz_org_sig <- sapply(km_solutions_org_sig,
                        function(x) min(sapply(x,length)))

km_clusters_org_sig <- sapply(km_solutions_org_sig[[which.max(scores_org_sig)]],
                       function(i) indicators[["org_sig"]][i,], simplify=FALSE)
km_clusters2_org_sig <- sapply(km_solutions_org_sig[minsz_org_sig>1]
                               [[which.max(scores_org_sig[minsz_org_sig>1])]],
                       function(i) indicators[["org_sig"]][i,], simplify=FALSE)
## sort of OK
## --------------------------------------------------------------------------
## --------------------------------------------------------------------------
## Make matrix to be displayed as a heatmap:

## Column 4 =ensembl_geneid [=ENSEMBL], column 4 =geneid[=SYMBOL],
## and the voom-normalized counts [columns 7-..] are the same for all
## pairwise comparisons (however the row order does depend on the comparison).
## -> can arbitrarily use comparison [[1]] to extract counts and their IDs:

voom <- as.matrix(DGE_results[[1]][,-(1:6)]) 
rownames(voom) <- DGE_results[[1]]$ensembl_geneid

## My previous approach was: map original Ensembl IDs to gene symbols,
## then extract genes in significantly enriched GO terms by symbol.
## This looses information in the mapping (see "voom_mapping"), but was
## unavoidable with Enrichr as Enrichr GO databases contain only gene symbols.
tmp <- remap_rownames(voom,  
                      new2old = DGE_results[[1]] %>% 
                                   select(ensembl_geneid,geneid) %>% 
                                   transmute(old=ensembl_geneid,new=geneid), 
                      merge_function=colMeans) ## voom is ~log2(CPM)
                                               ## colSums() makes no sense!
voom_mapped <- tmp$tbl
voom_mapping <- tmp$grp

## With org.Mm.eg.db or biomaRt, I have an Ensembl ID <-> GO mapping.
## However in the clusterProfiler ORA and GSEA results, I still report only
## gene symbols (I could have choosen otherwise!). 

## Because my GO gene sets here are Ensembl-based, I need to map the 
## gene sets to symbols, too:

## find the GO geneset of each symbol's Ensembl IDs:
GO_symbolsets <- map_genesets(genesets=GO_genesets$org_dge,
                              mapping=voom_mapping)


## for the clusterings (here, kmeans on significantly regulated genes,
##                            with Ensembl<->GO relation from org.Mm.eg.db):
i   <- which(minsz_org_sig>1) ## don't allow singleton vector clusters
tmp <- km_solutions_org_sig[i][[which.max(scores_org_sig[i])]]
km_org_sig_genesets <- groups_from_vector_clustering(tmp,
                                                     indicators[["org_sig"]])
                                                     

km_org_sig_symbolsets <- map_genesets(genesets= km_org_sig_genesets,
                                      mapping=voom_mapping,
                                      id_col="GO_group")


## --------------------------------------------------------------------------
## Can I partition the new clustering similar to the Enrichr-based old one?
load("DATA/order_464.RData")
subfig_terms <- sapply(c(1,2),
                       function(i) {
                          tmp <- order_464$GOterms[order_464$subfigure==i]
                          x <- Reduce(union,
                                      sapply(tmp,
                                          extractCapturedSubstrings,
                                                 ##pattern="(GO\\.\\d+):100\\%",
                                                 pattern="(GO\\.\\d+)",
                                                 global_search=TRUE
                                          ))
                          gsub("\\.",":",x) ## GO terms in input 
                                            ## had "." instead of ":"
                        },simplify=FALSE)
all(our_GO_terms %in% subfig_terms[[2]])
##[1] TRUE
sapply(GO_info[sub("\\.",":",subfig_terms[[1]])],function(x)x@Term)
## GO:0070498 
## "interleukin-1-mediated signaling pathway" 
## GO:0019221 
## "cytokine-mediated signaling pathway" 
## GO:0050727 
## "regulation of inflammatory response" 
## GO:0038061 
## "NIK/NF-kappaB signaling" 
## GO:0033209 
## "tumor necrosis factor-mediated signaling pathway" 
## GO:0071357 
## "cellular response to type I interferon" 
## GO:0043312 
## "neutrophil degranulation" 

sapply(GO_info[sub("\\.",":",setdiff(subfig_terms[[2]],subfig_terms[[1]]))],
       function(x)x@Term)
## GO:0071456 
## "cellular response to hypoxia" 
## GO:0002479 
## "antigen processing and presentation of exogenous peptide antigen 
##                                    via MHC class I, TAP-dependent" 
## GO:0036294 
## "cellular response to decreased oxygen levels" 

## define for now:
my_subfig_terms <- subfig_terms[[1]]
my_subfig_terms <- setdiff(subfig_terms[[2]],subfig_terms[[1]])
## (GO:0002479 should go from subfig2)

km_org_sig_subfigs <- list(setdiff(1:nrow(km_org_sig_symbolsets),c(2,3)),
                           c(2,3))

## a reduced dataset with a short name for testing:
km <-  km_org_sig_symbolsets[-c(1,3),]
km_subfigs <- list(c(2:6),c(1))

## --------------------------------------------------------------------------
## Draw the heatmap(s):
subfig_index <- 1
tmp <- stack_submatrices(voom_mapped, 
                         setNames(km$SYMBOL[km_subfigs[[subfig_index]]],
                                  km$GO_group[km_subfigs[[subfig_index]]])
                         )
m1 <- tmp$mat
r1 <- tmp$grp

tmp <- sapply(km$GO_group[km_subfigs[[subfig_index]]],
              function(x) sapply(extractCapturedSubstrings(x,
                                                    pattern="(GO\\.\\d+):",
                                                    global_search=TRUE),
                                 sub,
                                 pattern="\\.",
                                 replacement=":", USE.NAMES=FALSE),
              simplify=FALSE)


text_tags <-lapply(tmp,function(x) sapply(GO_info[x],function(y) y@Term))

condition_labels <- c(cre="control",
                      iko="aPKC",
                      p53="p53",
                      dko="dko")
conditions <- factor(extractCapturedSubstrings("\\.([^.]+)$",
                                               colnames(m1)),
                     levels=names(condition_labels))

draw_heatmap(m1,
             condition_colors=1:length(nice_colnames),## fill colors 
                                                      ## -- use standard colors
             condition_labels=condition_labels,   
             column_split=conditions,
             row_split=r1,
             tags=lapply(text_tags,names),##lapply(text_tags,function(x)paste(names(x),x,sep=":")),##text_tags,
             column_labels=colnames(m1),
             show_column_names=TRUE,
             outfile=NULL) ##paste0("testout_",subfig_index,".pdf"))
             

